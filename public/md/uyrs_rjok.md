# 工程文档

## json文件

```json
{
    "品牌标识":"BYDEV",
    "默认协议": [
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                6,
                14
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        },
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        }
    ],
    "默认数据流文件夹": "数据流",
    "默认版本信息文件夹": "版本信息",
    "默认读码文件夹": "读.*码",
    "默认清码文件夹": "清.*码"
}
```

json文件用于描述工程以及资料。是不可或缺的配置文件。


### 专用属性

#### 品牌标识
```json
{
    "品牌标识":"BYDEV"
}
```
**品牌标识** 指定了该工程的加密资料在`云电动力`的`Vehicle`目录下的存放位置。该属性一般用于project.json配置。一个工程需要唯一个project.json来配置该工程的基本信息。当然，你可以直接使用初始化指令`proj=init`来新建一个初始的project.json。

### 公用属性

公用属性可用于配置project.json或config.json。

#### 默认协议
```json
{
    "默认协议": [
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                6,
                14
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        },
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        }
    ]
}

```
该属性指定当前文件夹以及子文件夹所使用的通讯协议。子文件夹可以修改该属性，方法是，在它的目录下的config.json里指定`当前协议`，这样，程序就能将`当前协议`支配给`默认协议`的所有子对象。

子文件夹也可以重新指定`默认协议`，彻底地修改当前文件夹和子文件夹的通讯协议，所使用的方法同样是在它的config.json里面直接指定`默认协议`。以下是`默认协议`示例。

##### CANBUS-J1939协议


```json
{
    "默认协议": [
        {
            "协议类型": "CANBUS-J1939",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "广播ID":"0x45c"
        }
    ]
}

```
J1939协议基于CANBUS系统，使用该协议的ECU是自发式、广播式地向公共回路发送数据。无需请求应答。

广播ID只需填一个ID就行，不能填多个ID. 该属性仅作为检测通讯是否成功的依据。

##### CANBUS11协议
```json
{
    "默认协议": [
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        }
    ]
}

```

##### CANBUS29协议
```json
{
    "默认协议": [
        {
            "协议类型": "CANBUS29",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80"
        }
    ]
}

```

#### 当前协议
```json
{
    "当前协议":{
        "请求ID":"fc00",
        "应答ID":"fd00"
    }
}

```

若文件夹指定了`当前协议`，程序会将`当前协议`的所有子属性赋予`默认协议`的所有子对象。效果如下：

```json
{
    "默认协议": [
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                6,
                14
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80",
            "请求ID":"fc00",
            "应答ID":"fd00"
        },
        {
            "协议类型": "CANBUS11",
            "波特率": 500,
            "引脚": [
                3,
                11
            ],
            "会话模式": "02 10 01",
            "link": "02 3e 80",
            "请求ID":"fc00",
            "应答ID":"fd00"
        }
    ]
}

```

#### 单体

```json
{
    "当前文件夹属性":"单体",
    "电压":{},
    "温度":{}
}
```
开发J1939型单体电压或单体温度，一个config.json文件就能搞定。**电压** 属性用来指定单体电压的ID(地址)和它们所对应的算法。**温度** 属性用来指定单体温度的ID(地址)和它们所对应的算法。

单体电压或单体温度一般使用J1939协议直接广播。其他ECU可以随时在CANBUS中获取这些单体信息。

##### 多ID类型
```json
{
    "当前文件夹属性": "单体",
    "电压": {
        "ID": [
            "0x451",
            "0x452",
            "0x453",
            "0x454",
            "0x455",
            "0x456",
            "0x457",
            "0x458",
            "0x459"
        ],
        "参考": [
            "d3d4*0.001",
            "d5d6*0.001",
            "d7d8*0.001"
        ]
    }
}
```
这段配置是常见的多ID单体配置。

```json
{
    "参考": [
        "d3d4*0.001",
        "d5d6*0.001",
        "d7d8*0.001"
    ]
}
```

`参考`属性指定的是每帧参考的算法。每帧字节用d1-d8来表示。

##### 单ID类型
```json
{
    "当前文件夹属性": "单体",
    "电压": {
        "参考": [
            "d3d4*0.001",
            "d5d6*0.001",
            "d7d8*0.001"
        ],
        "0x456":{
            "帧数":23,
            "标识":[
                1
            ],
            "23":[
                "d3d4*0.001",
                "d5d6*0.001"
            ]
        }
    }
}
```
这段配置是常见的单个ID单体配置，这个ID存在多帧传输。当ECU使用多帧传输时，每帧必定有标识字节。

```json
{
    "0x456":{
        "帧数":23,
        "标识":[
            1
        ],
        "23":[
            "d3d4*0.001",
            "d5d6*0.001"
        ]
    }
}
```

这里"0x456"声明了一个ID为0x456的项目，该项目存在多帧传输。

```json
{
    "23":[
        "d3d4*0.001",
        "d5d6*0.001"
    ]
}
```
上面的"23"属性，表示要声明当前ID所对应的第23帧的算法。当某一帧的算法与参考算法不一致时，可以像上面这样直接指定该帧算法。

```json
{
    "23":[ ]
}
```

像这样的，如果某一帧不存在单体电压或温度，则可以单独声明该帧算法，然后把它设为空数组。

##### 多ID多帧传输类型(少见)

```json
{
    "当前文件夹属性": "单体",
    "测试":"发码.txt",
    "电压": {
        "ID": [
            "0x451",
            "0x452",
            "0x453",
            "0x454",
            "0x455",
            "0x456",
            "0x457",
            "0x458",
            "0x459"
        ],
        "参考": [
            "d3d4*0.001",
            "d5d6*0.001",
            "d7d8*0.001"
        ],
        "0x451": {
            "帧数": 3,
            "标识": [
                1,
                2
            ],
            "3": [
                "d3d4*0.002",
                "d5d6*0.002"
            ]
        }
    },
    "温度": {
        "ID": [
            "0x558",
            "0x559"
        ],
        "参考": [
            "d1-40",
            "d2-40",
            "d3-40",
            "d4-40"
        ],
        "0x558": {
            "帧数": 3,
            "标识": [
                1,
                2
            ],
            "3": [
                "d3-40"
            ]
        }
    }
}
```
多个ID传输单体电压或单体温度的同时，单个ID又存在多帧传输时，可以参考这个示例。
##### 多帧拼接类型(少见)

```json
{
    "当前文件夹属性": "单体",
    "测试": "发码.txt",
    "电压": {
        "多帧拼接": {
            "标识": [
                1
            ]
        },
        "ID": [
            "0x214",
            "0x224",
            "0x234",
            "0x244"
        ],
        "参考": [
            "d2d3*0.001"
        ]
    }
}
```

这是J1939中 **多帧拼接** 类型的单体配置示例。该配置适应如下报文中的数据

```java
*{08 00 00 02 14 00 0f 80 0f 82 0f 81 0f};
*{08 00 00 02 14 01 80 0f 80 0f 82 0f 81};
*{08 00 00 02 14 02 0f 7f 0f 81 0f 82 0f};
*{04 00 00 02 14 03 81 0f 7e};
*{08 00 00 02 24 00 0f 8a 0f 8f 0f 8d 0f};
*{08 00 00 02 24 01 8d 0f 8f 0f 91 0f 8c};
*{08 00 00 02 24 02 0f 8d 0f 8b 0f 8d 0f};
*{04 00 00 02 24 03 8d 0f 8c};
*{08 00 00 02 34 00 0f 8e 0f 8d 0f 8d 0f};
*{08 00 00 02 34 01 91 0f 8e 0f 8f 0f 8c};
*{08 00 00 02 34 02 0f 8f 0f 8d 0f 8e 0f};
*{04 00 00 02 34 03 8f 0f 91};
*{08 00 00 02 44 00 0f 8f 0f 8d 0f 8c 0f};
*{08 00 00 02 44 01 8d 0f 8c 0f 8c 0f 8c};
*{08 00 00 02 44 02 0f 8d 0f 8d 0f 8d 0f};
*{04 00 00 02 44 03 8d 0f 88};
```

可以看到，同ID的各帧之间不是隔绝关系，它们需要头尾拼接起来，才能够进行正常解析。如果单体报文中存在`00 00`分割模组的情况，那么也可以使用`多帧拼接`算法。

```java
*{08 18 20 F4 02 0D 6D 0D 6B 0D 6D 0D 6E};
*{08 18 21 F4 02 00 00 0D 70 0D 6F 0D 70};
*{08 18 22 F4 02 0D 70 00 00 0D 6F 0D 51};
*{08 18 26 F4 02 0D 70 0D 6F 0D 6E 0D 6F};
*{08 18 27 F4 02 0D 6E 0D 6E 0D 6E 0D 6E};
*{08 18 28 F4 02 0D 6E 0D 6D 0E 17 0E 11};
*{08 18 29 F4 02 0F CA 0F 9C 0F 99 0F D7};
*{08 18 2A F4 02 0F 97 0F DC 00 00 0F C9};
*{08 18 2B F4 02 0F 7E 0F 99 0F DD 00 00};
*{08 18 2C F4 02 0F 91 0F CE 0F 9A 0F DD};
*{08 18 2D F4 02 00 00 0F DA 0F 9A 0F D5};
*{08 18 31 F4 02 0F 94 00 00 0F 91 0F 99};
*{08 18 32 F4 02 0F 5A 0F 92 0F 9D 0F A8};
*{08 18 33 F4 02 0F 9E 0F AB 09 C6 00 00};
```

若单体报文不存在多帧传输，没有标识字节，那么可以直接声明 **标识** 属性为空数组。

```json
{
    "当前文件夹属性": "单体",
    "测试": "发码.txt",
    "电压": {
        "多帧拼接": {
            "标识": []
        },
        "ID": [
            "0x1820F402",
            "0x1821F402",
            "0x1822F402",
            "0x1826F402",
            "0x1827F402",
            "0x1828F402",
            "0x1829F402",
            "0x182AF402",
            "0x182BF402",
            "0x182CF402",
            "0x182DF402",
            "0x1831F402",
            "0x1832F402",
            "0x1833F402"
        ],
        "参考": [
            "d1d2*0.001"
        ]
    }
}
```
#### 声明全局数据

声明全局数据的好处是数据可被重复使用。

```json
{
    "声明全局数据": [
        {
            "数据名": "默认版本信息",
            "数据属性": "版本信息",
            "引入文件": "默认版本信息.vr"
        },
        {
            "数据名": "默认读码",
            "数据属性": "读码",
            "引入文件": "默认读码.peng"
        },
        {
            "数据名": "默认清码",
            "数据属性": "清码",
            "引入文件": "默认清码.peng"
        }
    ]
}

```

全局数据的身份统一使用 **数据名** 来标记，局内文件夹可以使用数据名引用对应的数据。

#### 电子控制单元默认含有

```json
{
    "电子控制单元默认含有":[
        {"文件夹属性":"版本信息", "文件夹名称":"版本信息","引用":"默认版本信息"},
        {"文件夹属性":"读码", "文件夹名称":"读故障码","引用":"默认读码"},
        {"文件夹属性":"清码", "文件夹名称":"清故障码","引用":"默认清码"}
    ]
}
```
**电子控制单元默认含有** 的优先级是最低的，当没有其他属性的阻挠时，该属性会生效。当电子控制单元的子文件夹没有默认含有的文件夹时(根据属性判断目标文件夹是否存在)，程序将根据`电子控制单元默认含有`的 **引用** 属性，将指定的数据名对应的数据作为该电子控制单元的数据。

#### 子文件夹不含有

```json
{
    "子文件夹不含有": [
        {
            "文件夹属性": "读码"
        },
        {
            "文件夹属性": "清码"
        }
    ]
}
```
通过指定 **子文件夹不含有** 某些文件夹，可以阻挠 **电子控制单元默认含有** 生效。

#### 数据流参数

```json
{
    "当前文件夹属性":"数据流",
    "数据流参数":["sortCandata=11"]
}
```

**数据流参数** 用于指定彭语言中`$Str()`的参数。多数情况下，执行该指令无需任何参数。而如果该数据流使用的是J1939协议，并且存在多帧传输时，则需要指定一个数据流参数: sortCandata。该参数用于将接收到的多帧数据进行重新排序。

```java
$Str(sortCandata=11);
```

## 谢谢浏览